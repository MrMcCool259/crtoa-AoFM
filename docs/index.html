<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Polyomino Solver Preview — transcribed shapes (7x7)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background: #0f1724; color: #e6eef8; padding: 18px; }
  h1 { margin: 0 0 10px 0; font-size: 18px; }
  .container { display:flex; gap:18px; align-items:flex-start; }
  .board { background: linear-gradient(180deg,#111827,#0b1220); padding:12px; border-radius:10px; box-shadow: 0 6px 18px rgba(0,0,0,0.6); }
  .grid { display:grid; grid-template-columns: repeat(7,34px); grid-auto-rows:34px; gap:4px; }
  .cell { width:34px; height:34px; border-radius:6px; display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; font-size:12px; font-weight:700; transition: background .12s; }
  .cell.locked { background:#233045; border:1px solid #0f1724; color:#6b7280; }
  .cell.unlocked { background:#dbeafe; color:#022c3a; box-shadow: inset 0 -4px 8px rgba(0,0,0,0.06); }
  .cell.placed { color:#022c3a; }
  .placed-red { background: linear-gradient(135deg,#fca5a5,#fecaca); }
  .placed-green { background: linear-gradient(135deg,#86efac,#bbf7d0); }
  .placed-blue { background: linear-gradient(135deg,#93c5fd,#bfdbfe); }

  .controls { width:520px; }
  .palette { background: linear-gradient(180deg,#0b1220,#071021); padding:10px; border-radius:8px; max-height:640px; overflow:auto; }
  .category { margin-bottom:12px; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.03); }
  .category-title { font-weight:700; margin-bottom:8px; display:flex; align-items:center; gap:8px; color:#cfe8ff; }
  .color-dot { width:12px; height:12px; border-radius:50%; display:inline-block; }
  .color-red { background: linear-gradient(180deg,#f87171,#fecaca); box-shadow: inset 0 -2px rgba(0,0,0,0.08); }
  .color-green { background: linear-gradient(180deg,#4ade80,#bbf7d0); box-shadow: inset 0 -2px rgba(0,0,0,0.08); }
  .color-blue { background: linear-gradient(180deg,#60a5fa,#bfdbfe); box-shadow: inset 0 -2px rgba(0,0,0,0.08); }

  .shape-row { display:flex; gap:10px; align-items:center; margin-bottom:8px; padding:4px 2px; border-radius:6px; }
  .shape-row:hover { background: rgba(255,255,255,0.02); }
  .mini { display:grid; grid-template-columns:repeat(4,14px); grid-auto-rows:14px; gap:2px; background:transparent; }
  .mini .mcell { width:14px; height:14px; background: rgba(255,255,255,0.04); border-radius:2px; }
  .mini .mcell.on { background: linear-gradient(180deg,#bae6fd,#60a5fa); }
  .shape-id { width:46px; font-size:12px; color:#9fb6d4; }
  .count { display:flex; align-items:center; gap:6px; margin-left:auto; }
  .count input { width:44px; font-size:12px; padding:4px; border-radius:6px; border:1px solid #213244; background:#071021; color:#cfe8ff; text-align:center; }
  button { background:#2563eb; color:white; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
  button.secondary { background:#1f2937; color:#cfe8ff; border:1px solid #233045; }
  .footer { margin-top:10px; display:flex; gap:10px; align-items:center; }
  .placements { margin-top:8px; font-size:13px; color:#cfe8ff; max-height:220px; overflow:auto; }
  .placement-row { display:flex; gap:8px; align-items:center; margin-bottom:6px; }
  .placement-dot { width:14px; height:14px; border-radius:3px; display:inline-block; }
  .note { margin-top:10px; color:#9fb6d4; font-size:13px; }
  .topbar { display:flex; gap:12px; align-items:center; margin-bottom:8px; }
  .small { font-size:12px; color:#9fb6d4; }
</style>
</head>
<body>
<h1>Polyomino Solver Preview — transcribed shapes (7x7)</h1>
<div class="container">
  <div class="board">
    <div style="display:flex; gap:10px; align-items:center; margin-bottom:8px;">
      <div class="topbar">
        <button id="resetGrid" class="secondary">Reset default unlocked 3x5</button>
        <button id="clearSolution" class="secondary">Clear solution</button>
      </div>
    </div>
    <div id="grid" class="grid" title="Click to toggle unlocked/locked"></div>
    <div class="note">Click cells to toggle locked/unlocked. Unlocked cells are pale. Locked are dark. Placed pieces are colored by tile-count category.</div>
  </div>

  <div class="controls">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
      <div style="font-weight:700">Shape palette (grouped by tile count)</div>
      <div><button id="solveBtn">Solve</button></div>
    </div>
    <div class="palette" id="palette"></div>

    <div class="footer">
      <div style="flex:1">
        <div style="font-weight:700">Placements / Solution</div>
        <div class="placements" id="placements"></div>
      </div>
    </div>
    <div class="note">Colors: 1–3 tiles = red, 4 tiles = green, 5 tiles = blue. Rotations/reflections that look identical are deduplicated.</div>
  </div>
</div>

<script>
/* Client-side preview with the transcribed shapes from the picture.
   Applied modifications:
     - Tetromino S removed.
     - Pentominoes F, N, P, W, Y removed.
     - Pentomino I and L removed (per latest request).
     - Z pentomino uses 3x3 layout: XX. / .X. / .XX
*/

const ROWS = 7, COLS = 7;
let unlocked = Array.from({length:ROWS}, ()=>Array.from({length:COLS}, ()=>false));
let placedCells = {};
let shapeTypes = [];
let shapeCounts = {};

function applyDefaultCenter(){ unlocked = Array.from({length:ROWS}, ()=>Array.from({length:COLS}, ()=>false));
  const startR = Math.floor((ROWS-3)/2);
  const startC = Math.floor((COLS-5)/2);
  for(let r=startR; r<startR+3; r++){
    for(let c=startC; c<startC+5; c++){
      unlocked[r][c] = true;
    }
  }
}

function normalize(cells){
  if(cells.length===0) return [];
  let minr = Math.min(...cells.map(p=>p[0]));
  let minc = Math.min(...cells.map(p=>p[1]));
  const out = cells.map(p=>[p[0]-minr, p[1]-minc]);
  out.sort((a,b)=>a[0]-b[0] || a[1]-b[1]);
  return out;
}
function rotate90(cells){
  return normalize(cells.map(([r,c])=>[c, -r]));
}
function reflectX(cells){
  return normalize(cells.map(([r,c])=>[-r, c]));
}
function all8_unique(cells){
  const t0 = normalize(cells);
  const raw = [];
  let cur = t0;
  for(let i=0;i<4;i++){ raw.push(cur); cur = rotate90(cur); }
  cur = reflectX(t0);
  for(let i=0;i<4;i++){ raw.push(cur); cur = rotate90(cur); }
  const seen = new Set();
  const unique = [];
  for(const t of raw){
    const key = t.map(p=>p[0]+','+p[1]).join(';');
    if(!seen.has(key)){
      seen.add(key);
      unique.push(t);
    }
  }
  return unique;
}

/* Transcribed base shapes after requested removals (I and L pentomino removed) */
const baseShapes = [
  // 1~3 tiles
  {name:"monomino", cells:[[0,0]]},
  {name:"domino", cells:[[0,0],[0,1]]},
  {name:"tromino-I", cells:[[0,0],[0,1],[0,2]]},
  {name:"tromino-L", cells:[[0,0],[0,1],[1,0]]},

  // 4 tiles (tetrominoes) - S removed
  {name:"tetromino-I", cells:[[0,0],[0,1],[0,2],[0,3]]},
  {name:"tetromino-O", cells:[[0,0],[0,1],[1,0],[1,1]]},
  {name:"tetromino-T", cells:[[0,1],[1,0],[1,1],[1,2]]},
  {name:"tetromino-L", cells:[[0,0],[1,0],[2,0],[2,1]]},

  // 5 tiles (pentominoes) - I and L removed, others removed earlier
  // Remaining pentominoes included here: T, U, V, X, Z
  {name:"pentomino-T", cells:[[0,0],[0,1],[0,2],[1,1],[2,1]]},
  {name:"pentomino-U", cells:[[0,0],[0,2],[1,0],[1,1],[1,2]]},
  {name:"pentomino-V", cells:[[0,0],[1,0],[2,0],[2,1],[2,2]]},
  {name:"pentomino-X", cells:[[0,1],[1,0],[1,1],[1,2],[2,1]]},
  {name:"pentomino-Z", cells:[[0,0],[0,1],[1,1],[2,1],[2,2]]},
];

function buildShapeTypes(){
  shapeTypes = [];
  let sid = 1;
  for(const b of baseShapes){
    const transforms = all8_unique(b.cells);
    for(const t of transforms){
      const s = { id: "S"+sid, cells: t, baseName: b.name, size: t.length };
      shapeTypes.push(s);
      sid++;
    }
  }
}

/* UI rendering & solver (same as before) */

const gridEl = document.getElementById('grid');
const paletteEl = document.getElementById('palette');
const placementsEl = document.getElementById('placements');

function renderGrid(){
  gridEl.innerHTML = '';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const div = document.createElement('div');
      const k = r+','+c;
      const placed = placedCells[k];
      let className = 'cell ';
      if(placed) {
        className += 'placed ' + placed.colorClass;
      } else {
        className += (unlocked[r][c] ? 'unlocked' : 'locked');
      }
      div.className = className;
      div.dataset.rc = k;
      div.title = placed ? `Placed ${placed.pid}` : (unlocked[r][c] ? 'Unlocked' : 'Locked');
      div.textContent = placed ? placed.pid : '';
      div.addEventListener('click', ()=>{
        if(Object.keys(placedCells).length) clearSolution();
        unlocked[r][c] = !unlocked[r][c];
        renderGrid();
      });
      gridEl.appendChild(div);
    }
  }
}

function renderPalette(){
  paletteEl.innerHTML = '';

  const categories = {
    '1-3': { title: '1–3 tiles', colorClass: 'color-red', cssClass: 'placed-red', items: [] },
    '4':   { title: '4 tiles', colorClass: 'color-green', cssClass: 'placed-green', items: [] },
    '5':   { title: '5 tiles', colorClass: 'color-blue', cssClass: 'placed-blue', items: [] },
    'other': { title: 'other', colorClass: 'color-blue', cssClass: 'placed-blue', items: [] }
  };
  for(const s of shapeTypes){
    if(s.size >=1 && s.size <=3) categories['1-3'].items.push(s);
    else if(s.size ===4) categories['4'].items.push(s);
    else if(s.size ===5) categories['5'].items.push(s);
    else categories['other'].items.push(s);
  }

  function makeShapeRow(s){
    const row = document.createElement('div'); row.className='shape-row';
    const mini = document.createElement('div'); mini.className='mini';
    const maxR = Math.max(...s.cells.map(p=>p[0]));
    const maxC = Math.max(...s.cells.map(p=>p[1]));
    const h = Math.max(1, Math.min(4, maxR+1));
    const w = Math.max(1, Math.min(4, maxC+1));
    mini.style.gridTemplateColumns = `repeat(${w},14px)`;
    for(let rr=0; rr<h; rr++){
      for(let cc=0; cc<w; cc++){
        const mc = document.createElement('div'); mc.className='mcell';
        if(s.cells.some(p=>p[0]===rr && p[1]===cc)) mc.classList.add('on');
        mini.appendChild(mc);
      }
    }
    const idEl = document.createElement('div'); idEl.className='shape-id'; idEl.textContent = s.id;
    const nameEl = document.createElement('div'); nameEl.style.color='#9fb6d4'; nameEl.style.fontSize='12px'; nameEl.textContent = s.baseName + ` (${s.size})`;
    const countWrap = document.createElement('div'); countWrap.className='count';
    const minus = document.createElement('button'); minus.textContent='-'; minus.style.padding='4px 8px';
    const inp = document.createElement('input'); inp.type='number'; inp.min='0'; inp.value = shapeCounts[s.id]||0;
    const plus = document.createElement('button'); plus.textContent='+'; plus.style.padding='4px 8px';
    minus.addEventListener('click', ()=>{ inp.value = Math.max(0, parseInt(inp.value||0)-1); shapeCounts[s.id]=parseInt(inp.value||0); });
    plus.addEventListener('click', ()=>{ inp.value = Math.min(15, parseInt(inp.value||0)+1); shapeCounts[s.id]=parseInt(inp.value||0); });
    inp.addEventListener('change', ()=>{ let v=parseInt(inp.value||0); if(isNaN(v)||v<0) v=0; if(v>15) v=15; inp.value=v; shapeCounts[s.id]=v; });
    countWrap.appendChild(minus); countWrap.appendChild(inp); countWrap.appendChild(plus);

    row.appendChild(mini); row.appendChild(idEl); row.appendChild(nameEl); row.appendChild(countWrap);
    return row;
  }

  const order = ['1-3','4','5','other'];
  for(const key of order){
    const cat = categories[key];
    if(!cat) continue;
    const catDiv = document.createElement('div'); catDiv.className='category';
    const title = document.createElement('div'); title.className='category-title';
    const dot = document.createElement('span'); dot.className='color-dot ' + cat.colorClass;
    title.appendChild(dot);
    const txt = document.createElement('div'); txt.textContent = `${cat.title} `;
    txt.style.fontWeight='700';
    txt.style.color='#cfe8ff';
    title.appendChild(txt);
    const small = document.createElement('div'); small.className='small'; small.textContent = `(${cat.items.length} oriented shapes)`;
    title.appendChild(small);
    catDiv.appendChild(title);

    for(const s of cat.items){
      catDiv.appendChild(makeShapeRow(s));
    }
    paletteEl.appendChild(catDiv);
  }
}

function generatePlacementsFor(shape){
  const cells = shape.cells;
  const maxR = Math.max(...cells.map(p=>p[0]));
  const maxC = Math.max(...cells.map(p=>p[1]));
  const placements = [];
  for(let ar=0; ar+maxR<ROWS; ar++){
    for(let ac=0; ac+maxC<COLS; ac++){
      const abs = cells.map(([r,c])=>[r+ar, c+ac]);
      let ok = true;
      for(const [r,c] of abs){
        if(r<0||r>=ROWS||c<0||c>=COLS) { ok=false; break; }
        if(!unlocked[r][c]) { ok=false; break; }
      }
      if(ok) placements.push({shapeId: shape.id, anchor:[ar,ac], cells:abs});
    }
  }
  return placements;
}

function buildPlacementsMap(){
  const placementsByShape = {};
  for(const s of shapeTypes){
    const cnt = shapeCounts[s.id] || 0;
    if(cnt<=0) continue;
    const pls = generatePlacementsFor(s);
    placementsByShape[s.id] = pls;
  }
  return placementsByShape;
}

function solveOnce(maxPieces=15){
  const instances = [];
  const placementsByShape = buildPlacementsMap();
  for(const s of shapeTypes){
    const cnt = shapeCounts[s.id] || 0;
    for(let i=0;i<cnt;i++){
      instances.push({instanceId: s.id + '#' + i, shapeId: s.id});
    }
  }
  if(instances.length===0) return {ok: true, placements: []};
  if(instances.length > maxPieces) return {ok:false, error:'Total piece count exceeds max allowed.'};

  const instanceOptions = instances.map(inst => {
    const opts = placementsByShape[inst.shapeId] || [];
    return {inst, opts};
  });
  for(const io of instanceOptions){
    if(io.opts.length === 0) return {ok:false, error:'One or more requested piece types have no valid placements on current board.'};
  }
  instanceOptions.sort((a,b)=>a.opts.length - b.opts.length);

  const used = new Set();
  const chosenPlacements = [];
  let found = null;

  function backtrack(idx){
    if(found) return;
    if(idx >= instanceOptions.length){
      found = chosenPlacements.slice();
      return;
    }
    const {inst, opts} = instanceOptions[idx];
    for(const p of opts){
      let conflict = false;
      for(const [r,c] of p.cells){
        if(used.has(r+','+c)){ conflict = true; break; }
      }
      if(conflict) continue;
      for(const [r,c] of p.cells) used.add(r+','+c);
      chosenPlacements.push({instId:inst.instanceId, shapeId: p.shapeId, anchor:p.anchor, cells:p.cells});
      backtrack(idx+1);
      if(found) return;
      chosenPlacements.pop();
      for(const [r,c] of p.cells) used.delete(r+','+c);
    }
  }
  backtrack(0);
  if(found) return {ok:true, placements:found};
  return {ok:false, error:'No placement set found that fits all requested pieces.'};
}

function sizeToCategory(size){
  if(size >=1 && size <=3) return {name:"1–3 tiles", colorClass:"red", cssClass:"placed-red"};
  if(size === 4) return {name:"4 tiles", colorClass:"green", cssClass:"placed-green"};
  if(size === 5) return {name:"5 tiles", colorClass:"blue", cssClass:"placed-blue"};
  return {name: size + " tiles", colorClass:"blue", cssClass:"placed-blue"};
}

function visualizeSolution(sol){
  placedCells = {};
  for(let i=0;i<sol.length;i++){
    const pl = sol[i];
    const pid = 'P'+(i+1);
    const shape = shapeTypes.find(s=>s.id===pl.shapeId);
    const cat = sizeToCategory(shape ? shape.size : pl.cells.length);
    for(const [r,c] of pl.cells){
      placedCells[r+','+c] = { pid, colorClass: cat.cssClass };
    }
  }
  renderGrid();
  placementsEl.innerHTML = '';
  sol.forEach((pl,i)=>{
    const shape = shapeTypes.find(s=>s.id===pl.shapeId);
    const cat = sizeToCategory(shape ? shape.size : pl.cells.length);
    const div = document.createElement('div'); div.className='placement-row';
    const dot = document.createElement('span'); dot.className='placement-dot';
    dot.style.background = (cat.colorClass === 'red' ? 'linear-gradient(180deg,#f87171,#fecaca)' : (cat.colorClass === 'green' ? 'linear-gradient(180deg,#4ade80,#bbf7d0)' : 'linear-gradient(180deg,#60a5fa,#bfdbfe)')); dot.style.width='14px'; dot.style.height='14px';
    const txt = document.createElement('div'); txt.textContent = `${'P'+(i+1)}: ${pl.instId} (shape ${pl.shapeId}, size ${shape ? shape.size : pl.cells.length}) anchor=${pl.anchor}`;
    div.appendChild(dot); div.appendChild(txt);
    placementsEl.appendChild(div);
  });
}

function clearSolution(){
  placedCells = {};
  placementsEl.innerHTML = '';
  renderGrid();
}

document.getElementById('solveBtn').addEventListener('click', ()=>{
  placementsEl.innerHTML = 'Solving...';
  setTimeout(()=>{
    const res = solveOnce(15);
    if(res.ok){
      visualizeSolution(res.placements);
    } else {
      placementsEl.innerHTML = 'No solution: ' + (res.error || 'unknown');
      clearSolution();
    }
  }, 50);
});
document.getElementById('resetGrid').addEventListener('click', ()=>{ clearSolution(); applyDefaultCenter(); renderGrid(); });
document.getElementById('clearSolution').addEventListener('click', ()=>{ clearSolution(); });

/* Initialize */
applyDefaultCenter();
buildShapeTypes();
shapeTypes.forEach(s=> shapeCounts[s.id]=0);
renderPalette();
renderGrid();
</script>
</body>
</html>
Add polyomino preview for GitHub Pages
